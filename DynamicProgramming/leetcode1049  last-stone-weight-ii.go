package DynamicProgramming

/**
 * 01背包问题应用（dp）
 * 本题难在转换成01问题的过程，至于为什么可以转：理由如下：
 * 整个题目，每个回合数两两抽出来比较，两个数之差将被再一次扔到数组里面，继续上面的过程。每个回合都会丢失掉两个数字，
 * 加入一个新的数字，这个数字就是两个数的差。相当于来说，就是少了a和b，但是多了一个a-b，a,b就此消失，
 * 但是在下一回合，a-b可能又被抓出去pk，pk后a-b就此再消失了，又产生了新的一个差。那么每一步来说，其实就相当于a,b没有真正意义消失。
 * 到了最后一回合，我们可以知道，其实找出两个最接近的数字堆。 再举个例子：
 * [31,26,33,21,40] 1：40-21 [19,26,31,33] 2: 31-(40-21) [12,26,33] 3: 33-(31-(40-21)) [21,26] 4: 26-(33-(31-(40-21))) [5]
 * 总： （26+31+21） - （40+33） 这就是找出两个总和接近的两个堆。 如何让两个堆接近呢？
 * 那就是沿着中间分两半，找左右各自那一半，那么思路就来到了找出一半堆这里。那么就自然而然地来到取不取的问题，就是01背包问题。
 * PS：实际上思路应该是先转换为“分割等和子集”问题，再转换成01问题
 */
func lastStoneWeightII(stones []int) int {
	// 获取石头总重量
	var sum int
	for _, v := range stones {
		sum += v
	}
	// dp过程
	bagWeight := sum / 2 // 背包总重
	dp := make([]int, bagWeight+1)

	for i := 0; i < len(stones); i++ {
		for j := bagWeight; j >= stones[i]; j-- {
			// 递推公式
			dp[j] = max(dp[j], dp[j-stones[i]]+stones[i])
		}
	}
	// 经过dp过程后，dp[bagWeight]中保存的一定是最接近背包重量的石头总重，这是"小堆"，剩余重量是“大堆”
	// “大堆”与"小堆"之差才是最终答案。为什么dp[bagWeight]是"小堆"呢？这是因为sum可能为奇数，那么此时相近的
	// 两堆一定一大一小，由于 / 会取整，故按照bagWeight求出来的最大堆一定是“小堆”
	return sum - 2*dp[bagWeight]
}
