package DynamicProgramming

// 灵神题解：前缀和 -> 分组背包 -> 01 背包
// 由于每个piles都只能从栈顶中取元素，那么最终的结果就是每个piles都取了一个前缀
// 于是，每个前缀可以看成是一个物品，每个piles的所有前缀便是一组物品，形成分组背包
// 由于每一组物品至多只能取一个，可进一步转化为 01 背包
// dp[i][j] 表示前 i 组物品在背包总重量限制至多为 j 的情况下，能获取的最大价值
// 考虑到 01 背包的常见优化手段，二维 dp 可以降为一维
func maxValueOfCoins(piles [][]int, k int) int {
	dp := make([]int, k+1)
	bagWeight := 0 // 当前所有组物品所需要的最大背包重量

	for _, pile := range piles { // 遍历物品
		n := len(pile)
		// 计算前缀和（获取第 i 组的所有物品信息）
		for i := 1; i < n; i++ {
			pile[i] += pile[i-1]
		}
		// 获取当前所需背包最大重量
		bagWeight = min(bagWeight+n, k)
		// 倒序遍历背包。
		// 注意这里的剪枝：在含义上，背包的总重量为k，但如果当前所有组所需的最大背包重量不足k，
		// 后续的遍历则没有意义，因为此时能容纳所有组的物品，值均为当前所有组能提供的最大价值。
		// 在正确性上，虽然 dp[i][bagWeight_i] 的计算会依赖 dp[i][bagWeight_i - 1] 等值，
		// 且这些值并不存在（上一层记录的最大范围为 dp[i][bagWeight_(i-1)]，故这些值为零值），但这不影响结果
		// 因为这些值一定不会导致出 dp[i][bagWeight_i] 的最大价值，主要是因为此时背包没装满，既然没装满，那就还可以再装
		// 那么也就一定会有值比当前值大，所以这些值本质上也就是走个流程，实际上这些值一定能被覆盖，且 dp[i][bagWeight_i] 一定能取到最大值
		for j := bagWeight; j >= 1; j-- {
			for k, p := range pile[:min(j, n)] { // 注意 min(j, n) 保证了当前组的物品重量不超过背包总重量
				// 需要注意，在一维数组的情况下，dp[j] 已经包含了当前组不取物品的情况
				// 且该情况与上述讨论的依赖值不存在的情况是一致的，都不会阻碍最大价值的获取！
				dp[j] = max(dp[j], dp[j-k-1]+p)
			}
		}
	}

	return dp[k]
}
